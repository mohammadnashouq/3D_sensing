#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Oct 25 11:23:47 2022

This program is used to create plots from the runlogs.csv generated by running the stereo estimation algorithms.

Types of plots to be created:
    
    1. Average similarity metric for estimation type.
        - similarity metrics: [ssim, ssd, ncc]
        - estimation types: dynamic, naive
    
    2. Average similarity metric for picture names:
        - similarity metrics: [ssim, ssd, ncc]
        - image names: [aloe, art, baby, cloth, cones, rocks]
    
    3. Average similarity metrics for window size and image name:
        - window size: [1, 3, 5, 7]
        - image names: [aloe, art, baby, cloth, cones, rocks]

The plots will be automatically saved to the given folder. 

@author: daniel
"""

import os
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

IMAGES_PATH = '/home/daniel/source/repos/3dSensing/01_stereo/plots/'
os.chdir('/home/daniel/source/repos/3dSensing/01_stereo/')

# Reading and converting the dataset
df = pd.read_csv('runlogs.csv', sep=';', header=0)
df['time'] = df['time'] / 60
df = df.fillna(0.1)

#%% A method to save a figure
def save_fig(fig_id, tight_layout=True, fig_extension="png", resolution=300):
    path = os.path.join(IMAGES_PATH, fig_id + "." + fig_extension)
    print("Saving figure", fig_id)
    if tight_layout:
        plt.tight_layout()
    plt.savefig(path, format=fig_extension, dpi=resolution)

#%% Dynamic/naive

def get_ssd_name_plot(df, name, metric):
    # Group by image name and average out the columns
    df_name = df[df['name']==name].groupby(['image_name','window_size']).mean().reset_index()
    
    # Create and save plot
    plt.figure(figsize=(8,8))
    
    # Title and axes labels
    plt.title('Average ' + metric + ' in case of ' + name + ' estimation', size=16)
    plt.xlabel('Image name', size=14)
    plt.ylabel(metric, size=14)
    
    sns.barplot(data=df_name, x='image_name', y=metric, hue='window_size')
    save_fig(name + '_' + metric + '_figure')
    plt.show()

print('Creating plots for image similarity metrics...')
for name in ['dynamic','naive']:
    for metric in ['ssd','ssim','ncc']:
        get_ssd_name_plot(df, name, metric)
        
print("\n")

#%% Plots for execution time / window size

def get_ssd_name_plot(df, name):
    # Group by image name and average out the columns
    df_name = df[df['name']==name].groupby(['image_name','window_size']).mean().reset_index()
    
    # Create and save plot
    plt.figure(figsize=(8,8))
    
    # Title and axes labels
    plt.title('Average running time (m) in case of ' + name + ' estimation', size=16)
    plt.xlabel('Image name', size=14)
    plt.ylabel('Window size', size=14)
    
    sns.barplot(data=df_name, x='image_name', y='time', hue='window_size')

    save_fig('Average_time_' + name + '_figure')
    plt.show()

print('Creating plots for running time...')
for name in ['dynamic','naive']:
    get_ssd_name_plot(df, name)
        
print("\n")

#%% Plots for window size / similarity measure

def get_ssd_window_pot(df, image_name, similarity_measure):
    df_name = df[df['image_name'] == image_name].groupby(['image_name','window_size']).mean().reset_index()
    
    # Create and save plot
    plt.figure(figsize=(8,8))
    
    plt.title(similarity_measure + ' and window size in case of ' + image_name, size = 16)
    
    plt.xlabel('Window size', size = 14)
    plt.ylabel('Average Similarity', size = 14)
    
    sns.barplot(data=df_name, x='window_size', y=similarity_measure)
    
    save_fig('Average_' + similarity_measure + '_' + image_name + '_figure')
    plt.show()
    
print('Creating plots for metrics / image name...')
for n in list(df['image_name'].unique()):
    for m in ['ssim','ssd','ncc']:
        get_ssd_window_pot(df, n, m)
        
#%% Best parameters according to metrics

def get_best_params(image_name, metric):
    if(metric == 'ssd'):
        best_naive = df[df['image_name'] == image_name].groupby(['name']).min()[metric]['naive']
        best_dynamic = df[df['image_name'] == image_name].groupby(['name']).min()[metric]['dynamic']
    else:
        best_naive = df[df['image_name'] == image_name].groupby(['name']).max()[metric]['naive']
        best_dynamic = df[df['image_name'] == image_name].groupby(['name']).max()[metric]['dynamic']
    
    naive_params = df[df['image_name'] == image_name].loc[df[metric] == best_naive, :].head(1)
    dynamic_params = df[df['image_name'] == image_name].loc[df[metric] == best_dynamic, :].head(1)
    
    metrics = ['ssd','ssim','ncc']
    metrics.remove(metric)

    result = pd.concat([naive_params, dynamic_params], axis=0, ignore_index=True, sort=False).drop(metrics, axis=1)
    return result
    
metric = 'ssd'
best_params_ssd = pd.DataFrame(columns=df.columns)
for image_name in list(df['image_name'].unique()):
    part = get_best_params(image_name, metric)
    best_params_ssd = pd.concat([best_params_ssd, part], axis=0, ignore_index=True, sort=False).dropna(how='all', axis=1)

metric = 'ncc'    
best_params_ncc = pd.DataFrame(columns=df.columns)
for image_name in list(df['image_name'].unique()):
    part = get_best_params(image_name, metric)
    best_params_ncc = pd.concat([best_params_ncc, part], axis=0, ignore_index=True, sort=False).dropna(how='all', axis=1)
    

metric = 'ssim'    
best_params_ssim = pd.DataFrame(columns=df.columns)
for image_name in list(df['image_name'].unique()):
    part = get_best_params(image_name, metric)
    best_params_ssim = pd.concat([best_params_ssim, part], axis=0, ignore_index=True, sort=False).dropna(how='all', axis=1)
    
 
for df_metric, metric in zip([best_params_ssd, best_params_ssim, best_params_ncc], ['ssd','ssim','ncc']):
    df_metric.to_csv('best_params_' + metric + '.csv', header=True, index=False)